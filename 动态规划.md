## 动态规划（dynamic programming）

### 动态规划使用场景：

子问题重叠，也就是不同的子问题具有公共的子子问题，子问题的求解是递归进行的，将其划分为更小的子问题。在这种情况下不使用分治算法是因为，分治算法会做许多不必要的工作，会将反复得求解那些公共子问题，而动态规划每个子问题只求解一次，将其保存在一个表格中，所以不必要每次都重新计算

动态规划常常用来求解最优化问题，这类问题可以有很多可行解，每个解都有一个值，我们希望寻找具有最优值的解，我们称这样的解为问题的一个最优解，而不是最优解，因为可能有很多个解都达到最优解。

### 设计一个动态规划算法

1. 刻画一个最优解的结构特性

2. 递归底定义最优解的值

3. 计算最优解的值，通常采用**自底向上**的方法

4. 利用计算出的信息构造一个最优解

   

### 动态规划例题

#### 钢条切割

> 给定一段长度为n英寸的钢条个一个价格表，求钢条切割方案，使得销售收益rn最大，这里需要注意的是，如果长度为n的钢条的价格p足够大的话，最优解可能就是完全不需要切割。

| 长度 | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 价格 | 1    | 5    | 8    | 9    | 10   | 17   | 17   | 20   | 24   | 30   |

比如，下图给出了n=4的时候的所有的可能的切割方案，当然也包括根本不切割的方案，由下图我们可以看出10为最优的收益，也就是最优解。

![image-20200911113018583](images\image-20200911113018583.png)

这里我们先来思考一下长度为n的钢条有几种切割方案，在每1个单位的钢条处我们可以选择切或者不切，这样的话我们可以得出一共有2<sup>n-1</sup>种方案。

假如我们使用每段的长度来表示每一个切割的方案，那么如果一个最优解将钢条切割为k段（1<=k<=n）,那么最优切割方案n = i<sub>i</sub>+i<sub>2</sub>+i<sub>3</sub>+...+i<sub>k</sub> 表示将钢条切割为i<sub>k</sub>的小段，得到最大收益r<sub>n</sub>=p<sub>i<sub>1</sub></sub>+p<sub>i<sub>2</sub></sub>+...+p<sub>i<sub>k</sub></sub>

对于上面的表格案例，我们可以观察出所有的最优收益值

r<sub>1</sub>=1   切割方案 1=1 （无切割）

r<sub>2</sub>=5   切割方案 2=2 （无切割）

r<sub>3</sub>=8   切割方案 3=3（无切割）

r<sub>4</sub>=10   切割方案 4=2+2

r<sub>5</sub>=13   切割方案 5=2+3

r<sub>6</sub>=17   切割方案 6=6 （无切割）

r<sub>7</sub>=18   切割方案 7=1+6或者7=2+2+3

r<sub>8</sub>=22   切割方案 8=2+6

r<sub>9</sub>=25   切割方案 9=3+6

r<sub>10</sub>=30   切割方案 10=10 （无切割）

更一般地，对于r<sub>n</sub>=max(p<sub>n</sub>,r<sub>1</sub>+r<sub>n-1</sub>,...r<sub>n-1</sub>+r<sub>1</sub>)

第一个参数p<sub>n</sub>对应的是不切割,直接出售长度为n英寸的钢条，其他n-1个参数对应另外n-1种方案：对于每个i=1,2,...n-1，首先将其切为i和n-i的两段，接着求解这两段的最优收益，因为无法提前知道哪种方案最优，我们必须考察每一种可能，然后选择最大收益。

为了求解规模为n的原问题，我们先求解形式完全一样，但规模更小的系问题。即当完成首次切割后，我们将两段钢条看成2个完全独立的切割问题，我们通过组合两个子问题的最优解，并在所有可能的两段切割方案中选取组合收益最大者，来作为原问题的最优解。我们成这个问题满足最优子结构（optimal substrcture）性质：问题的最优解由相关子问题的最优解组合而成，而这些子问题可以独立求解。

其实上诉问题还有一种更简单的递归求解办法

```
CUT-ROD(p,n)
	if n == 0
		return 0
q=-10000
for i =1 to n
	q=max(q,p[i]+CUT-ROD(p,n-i))
return q	
```

这段代码的时间复杂度是指数级别的。

下面使用动态规划来求解最优解切割问题。

朴素递归方法之所以效率低，是因为他反复求解相同的子问题。因此，动态规划方法其实采用的是每个子问题求解一次，然后将结果保存下来。如果接下来再需要这个子问题的解那么直接查询即可。也就是说，动态规划算法使用的是用空间换时间。是典型的时空权衡（time-memory trade-off）的例子，而时间上的节省是非常巨大的：可将指数级别的时间转换为一个多项式的实际。

### 动态规划的实现方法

#### 带备忘的自顶向下法（top-down with memorization）

这种方法仍然是按照递归的形式编写，但过程中会保存每个子问题的解（数组或散列表中）。当需要一个子问题的解的时候，先检查是否有保存，有直接返回，无则计算并保存。我们称这个递归过程是带备忘的，因为它记住了之前已经计算出的结果。

```
MEMOIZED-CUT-ROD(p,n)
	let r[0,,n] be a new array
	for i ==0 to n
		r[i]=负无穷
	return MEMOIZED-CUT-ROD-AUX(p,n,r)
    
MEMORIZED-CUT-ROD-AUX(p,n,r)
	if r[n]>=0
		return r[n]
	if n == 0 
    	q=0
	else q= 负无穷
    	for i ==1 to n
    		q=max(q,p[i]+MEMORIZED-CUT-ROD-AUX(p,n-i,r))
	r[n]=q
    return q
```



#### 自底向上法（bottom-up method）

这种方法需要恰当定义子问题规模的概念，使得任何子问题的求解都只依赖于更小的子问题。将问题规模排序，按照从小到大的顺序求解，当求解某个子问题的时候他所依赖的那些更小的子问题都已经求解完毕，结果已经保存，这样可以保证每个子问题都只求解一次。

```
BOTTOM-UP-CUT-ROD(p,n)
	let r[0,,n] be a new array
	r[0]=0  # 长度为0的时候没有收益
	for j=1 to n
		q=负无穷
		for i=1 to j
			q=max(q,p[i]+r[j-i])
		r[j]=q
	return r[n]       
```

这两种方式的时间复杂度都是O(n<sup>2</sup>)

### 子问题图

当思考一个动态规划问题时，我们应该弄清所涉及的子问题及子问题之间的依赖关系。

### 重构解

前面的算法只是给出了最优解的收益值，但是并不返回解本身。我们可以扩展动态规划算法，使得其每个子问题不仅保存最优收益，还保存对应的方案、

#### BOTTON-UP-CUT-ROD扩展版

```
EXTENDED-BOTTOM-UP-CUT-ROD(p,n)
	let r[0,,n] and s[0,n] be a new arrays
	r[0]=0
	for j==1 to n
		q=负无穷
		for i==1 to j
			if q<p[i]+r[j-i]
				q=p[i]+r[j-i]
				s[j]=i
		r[j]=q
return r and s        
```

